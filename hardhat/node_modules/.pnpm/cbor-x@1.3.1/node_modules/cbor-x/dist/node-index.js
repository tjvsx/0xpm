var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
__export(exports, {
  ALWAYS: () => import_encode.ALWAYS,
  DECIMAL_FIT: () => import_encode.DECIMAL_FIT,
  DECIMAL_ROUND: () => import_encode.DECIMAL_ROUND,
  Decoder: () => import_decode.Decoder,
  DecoderStream: () => import_stream.DecoderStream,
  Encoder: () => import_encode.Encoder,
  EncoderStream: () => import_stream.EncoderStream,
  FLOAT32_OPTIONS: () => import_decode.FLOAT32_OPTIONS,
  NEVER: () => import_encode.NEVER,
  REUSE_BUFFER_MODE: () => import_encode.REUSE_BUFFER_MODE,
  Tag: () => import_decode.Tag,
  addExtension: () => import_encode.addExtension,
  clearSource: () => import_decode.clearSource,
  decode: () => import_decode.decode,
  decodeIter: () => import_iterators.decodeIter,
  decodeMultiple: () => import_decode.decodeMultiple,
  encode: () => import_encode.encode,
  encodeIter: () => import_iterators.encodeIter,
  isNativeAccelerationEnabled: () => import_decode.isNativeAccelerationEnabled,
  mapsAsObjects: () => mapsAsObjects,
  roundFloat32: () => import_decode.roundFloat32,
  useRecords: () => useRecords
});
var import_encode = __toModule(require("./encode.js"));
var import_decode = __toModule(require("./decode.js"));
var import_stream = __toModule(require("./stream.js"));
var import_iterators = __toModule(require("./iterators.js"));
var import_decode2 = __toModule(require("./decode.js"));
var import_module = __toModule(require("module"));
const import_meta = {};
const useRecords = false;
const mapsAsObjects = true;
const extractor = tryRequire("cbor-extract");
if (extractor)
  (0, import_decode2.setExtractor)(extractor.extractStrings);
function tryRequire(moduleId) {
  try {
    let require2 = (0, import_module.createRequire)(import_meta.url);
    return require2(moduleId);
  } catch (error) {
    if (typeof window != "undefined")
      console.warn("For browser usage, directly use cbor-x/decode or cbor-x/encode modules. " + error.message.split("\n")[0]);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ALWAYS,
  DECIMAL_FIT,
  DECIMAL_ROUND,
  Decoder,
  DecoderStream,
  Encoder,
  EncoderStream,
  FLOAT32_OPTIONS,
  NEVER,
  REUSE_BUFFER_MODE,
  Tag,
  addExtension,
  clearSource,
  decode,
  decodeIter,
  decodeMultiple,
  encode,
  encodeIter,
  isNativeAccelerationEnabled,
  mapsAsObjects,
  roundFloat32,
  useRecords
});
