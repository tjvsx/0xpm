(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e=e||self,t(e.CBOR={}))})(this,function(e){'use strict';var t=Math.log,s=Math.round,n=Math.exp;function a(){try{let e=r();if(K&&(// bundled strings to skip past
B=K.postBundlePosition),B==x)T=null,V=null,Y&&(Y=null);else if(B>x){// over read
let e=new Error("Unexpected end of CBOR data");throw e.incomplete=!0,e}else if(!X)throw new Error("Data read, but end of buffer not reached");// else more to read, but we are reading sequentially, so don't clear source yet
return e}catch(e){throw k(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer"))&&(e.incomplete=!0),e}}function r(){let e=V[B++],t=e>>5;if(e&=31,23<e)switch(e){case 24:e=V[B++];break;case 25:if(7==t)return l();e=W.getUint16(B),B+=2;break;case 26:if(7==t){let e=W.getFloat32(B);if(2<q.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let t=le[(127&V[B])<<1|V[B+1]>>7];return B+=4,(t*e+(0<e?.5:-.5)>>0)/t}return B+=4,e}e=W.getUint32(B),B+=4;break;case 27:if(7==t){let e=W.getFloat64(B);return B+=8,e}if(1<t){if(0<W.getUint32(B))throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");e=W.getUint32(B+4)}else q.int64AsNumber?(e=4294967296*W.getUint32(B),e+=W.getUint32(B+4)):e=W.getBigUint64(B);B+=8;break;case 31:// indefinite length
switch(t){case 2:// byte string
case 3:// text string
throw new Error("Indefinite length not supported for byte or text strings");case 4:// array
let e,s=[],n=0;for(;(e=r())!=w;)s[n++]=e;return 4==t?s:3==t?s.join(""):Buffer.concat(s);case 5:// map
let a;if(q.mapsAsObjects){let e={};if(q.keyMap)for(;(a=r())!=w;)e[q.decodeKey(a)]=r();else for(;(a=r())!=w;)e[a]=r();return e}else{z&&(q.mapsAsObjects=!0,z=!1);let e=new Map;if(q.keyMap)for(;(a=r())!=w;)e.set(q.decodeKey(a),r());else for(;(a=r())!=w;)e.set(a,r());return e}case 7:return w;default:throw new Error("Invalid major type for indefinite length "+t);}default:throw new Error("Unknown token "+e);}switch(t){case 0:// positive int
return e;case 1:// negative int
return~e;case 2:// buffer
return c(e);case 3:// string
if(H>=B)return F.slice(B-G,(B+=e)-G);if(0==H&&140>x&&32>e){// for small blocks, avoiding the overhead of the extract call is helpful
let t=16>e?u(e):d(e);if(null!=t)return t}return te(e);case 4:// array
let s=Array(e);//if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())	
//else 
for(let t=0;t<e;t++)s[t]=r();return s;case 5:// map
if(q.mapsAsObjects){let t={};if(q.keyMap)for(let s=0;s<e;s++)t[q.decodeKey(r())]=r();else for(let s=0;s<e;s++)t[r()]=r();return t}else{z&&(q.mapsAsObjects=!0,z=!1);let t=new Map;if(q.keyMap)for(let s=0;s<e;s++)t.set(q.decodeKey(r()),r());else for(let s=0;s<e;s++)t.set(r(),r());return t}case 6:// extension
if(e>=P){let t=T[8191&e];// check record structures first
// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))
if(t)return t.read||(t.read=i(t)),t.read();if(65536>e){if(e==D)// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
return ie(r());if(e==L){let e=y(),t=r();for(let s=2;s<e;s++)ie([t++,r()]);return r()}if(e==P)return h();if(q.getShared&&(m(),t=T[8191&e],t))return t.read||(t.read=i(t)),t.read()}}let n=J[e];if(n)return n.handlesRead?n(r):n(r());else{let t=r();for(let s,n=0;n<$.length;n++)if(s=$[n](e,t),void 0!==s)return s;return new ae(t,e)}case 7:// fixed value
switch(e){case 20:return!1;case 21:return!0;case 22:return null;case 23:return;// undefined
case 31:default:let t=(N||f())[e];if(void 0!==t)return t;throw new Error("Unknown token "+e);}default:// negative int
if(isNaN(e)){let e=new Error("Unexpected end of CBOR data");throw e.incomplete=!0,e}throw new Error("Unknown CBOR token "+e);}}function i(e){function t(){// get the array size from the header
let e=V[B++];//let majorType = token >> 5
if(e&=31,23<e)switch(e){case 24:e=V[B++];break;case 25:e=W.getUint16(B),B+=2;break;case 26:e=W.getUint32(B),B+=4;break;default:throw new Error("Expected array header, but got "+V[B-1]);}// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
let t=this.compiledReader;// first look to see if we have the fast compiled function
for(;t;){// we have a fast compiled object literal reader
if(t.propertyCount===e)return t(r);// with the right length, so we use it
t=t.next}if(3<=this.slowReads++){// create a fast compiled reader
let s=this.length==e?this:this.slice(0,e);return t=q.keyMap?new Function("r","return {"+s.map(e=>q.decodeKey(e)).map(e=>ee.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}"):new Function("r","return {"+s.map(e=>ee.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}"),this.compiledReader&&(t.next=this.compiledReader),t.propertyCount=e,this.compiledReader=t,t(r)}let s={};if(q.keyMap)for(let t=0;t<e;t++)s[q.decodeKey(this[t])]=r();else for(let t=0;t<e;t++)s[this[t]]=r();return s}return e.slowReads=0,t}function o(e){let t;if(16>e&&(t=u(e)))return t;if(64<e&&C)return C.decode(V.subarray(B,B+=e));const s=B+e,n=[];for(t="";B<s;){const e=V[B++];if(0==(128&e))n.push(e);else if(192==(224&e)){// 2 bytes
const t=63&V[B++];n.push((31&e)<<6|t)}else if(224==(240&e)){// 3 bytes
const t=63&V[B++],s=63&V[B++];n.push((31&e)<<12|t<<6|s)}else if(240==(248&e)){// 4 bytes
const t=63&V[B++],s=63&V[B++],a=63&V[B++];let r=(7&e)<<18|t<<12|s<<6|a;65535<r&&(r-=65536,n.push(55296|1023&r>>>10),r=56320|1023&r),n.push(r)}else n.push(e);4096<=n.length&&(t+=se.apply(String,n),n.length=0)}return 0<n.length&&(t+=se.apply(String,n)),t}function d(e){let t=B,s=Array(e);for(let n=0;n<e;n++){const e=V[B++];if(0<(128&e))return void(B=t);s[n]=e}return se.apply(String,s)}function u(t){if(4>t){if(!(2>t)){let e=V[B++],s=V[B++];if(0<(128&e)||0<(128&s))return void(B-=2);if(3>t)return se(e,s);let n=V[B++];return 0<(128&n)?void(B-=3):se(e,s,n)}if(0===t)return"";else{let e=V[B++];return 1<(128&e)?void(B-=1):se(e)}}else{let s=V[B++],a=V[B++],r=V[B++],u=V[B++];if(0<(128&s)||0<(128&a)||0<(128&r)||0<(128&u))return void(B-=4);if(6>t){if(4===t)return se(s,a,r,u);else{let t=V[B++];return 0<(128&t)?void(B-=5):se(s,a,r,u,t)}}else if(8>t){let n=V[B++],e=V[B++];if(0<(128&n)||0<(128&e))return void(B-=6);if(7>t)return se(s,a,r,u,n,e);let i=V[B++];return 0<(128&i)?void(B-=7):se(s,a,r,u,n,e,i)}else{let d=V[B++],e=V[B++],c=V[B++],p=V[B++];if(0<(128&d)||0<(128&e)||0<(128&c)||0<(128&p))return void(B-=8);if(10>t){if(8===t)return se(s,a,r,u,d,e,c,p);else{let t=V[B++];return 0<(128&t)?void(B-=9):se(s,a,r,u,d,e,c,p,t)}}else if(12>t){let n=V[B++],i=V[B++];if(0<(128&n)||0<(128&i))return void(B-=10);if(11>t)return se(s,a,r,u,d,e,c,p,n,i);let o=V[B++];return 0<(128&o)?void(B-=11):se(s,a,r,u,d,e,c,p,n,i,o)}else{let f=V[B++],i=V[B++],g=V[B++],h=V[B++];if(0<(128&f)||0<(128&i)||0<(128&g)||0<(128&h))return void(B-=12);if(!(14>t)){let l=V[B++],y=V[B++];if(0<(128&l)||0<(128&y))return void(B-=14);if(15>t)return se(s,a,r,u,d,e,c,p,f,i,g,h,l,y);let n=V[B++];return 0<(128&n)?void(B-=15):se(s,a,r,u,d,e,c,p,f,i,g,h,l,y,n)}if(12===t)return se(s,a,r,u,d,e,c,p,f,i,g,h);else{let t=V[B++];return 0<(128&t)?void(B-=13):se(s,a,r,u,d,e,c,p,f,i,g,h,t)}}}}}function c(e){return q.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(V,B,B+=e):V.subarray(B,B+=e)}function l(){let e,t=V[B++],s=V[B++],a=(t<<8)+s,r=31&a>>10,i=1023&a;return e=0==r?n(i,-24):31==r?0==i?1/0:NaN:n(i+1024,r-25),32768&a?-e:e}function p(e,t){return"string"==typeof e?e+t:e instanceof Array?e.concat(t):Object.assign({},e,t)}function f(){if(!N)if(q.getShared)m();else throw new Error("No packed values available");return N}function g(e,t){let s=re[e+"Array"],n=s.BYTES_PER_ELEMENT;for(let a=0;2>a;a++){if(!a&&1==n)continue;let r=2==n?1:4==n?2:3;J[a?t:t-4]=1==n||a==de?e=>{if(!s)throw new Error("Could not find typed array for code "+t);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new s(Uint8Array.prototype.slice.call(e,0).buffer)}:n=>{if(!s)throw new Error("Could not find typed array for code "+t);let o=new DataView(n.buffer,n.byteOffset,n.byteLength),d=n.length>>r,u=new s(d),c=o["get"+e];for(let e=0;e<d;e++)u[e]=c.call(o,e<<r,a);return u}}}function h(){let e=y(),t=B+r();for(let t,s=2;s<e;s++)// skip past bundles that were already read
// this will increment position, so must add to position afterwards
t=y(),B+=t;let s=B;return B=t,K=[o(y()),o(y())],K.position0=0,K.position1=0,K.postBundlePosition=B,B=s,r()}function y(){let e=31&V[B++];return 23<e&&(24===e?e=V[B++]:25===e?(e=W.getUint16(B),B+=2):26===e?(e=W.getUint32(B),B+=4):void 0),e}function m(){if(q.getShared){let e=b(()=>(V=null,q.getShared()))||{},t=e.structures||[];q.sharedVersion=e.version,N=q.sharedValues=e.packedValues,!0===T?q.structures=T=t:T.splice.apply(T,[0,t.length].concat(t))}}function b(e){let t=x,s=B,n=G,a=H,r=F,i=Y,o=K,d=new Uint8Array(V.slice(0,x)),u=T,c=q,l=X,p=e();return x=t,B=s,G=n,H=a,F=r,Y=i,K=o,V=d,X=l,T=u,q=c,W=new DataView(V.buffer,V.byteOffset,V.byteLength),p}function k(){V=null,Y=null,T=null}function O(e){J[e.tag]=e.decode}function R(e){24>e?Ie[Ae++]=128|e:256>e?(Ie[Ae++]=152,Ie[Ae++]=e):65536>e?(Ie[Ae++]=153,Ie[Ae++]=e>>8,Ie[Ae++]=255&e):(Ie[Ae++]=154,Ue.setUint32(Ae,e),Ae+=4)}function M(e,t){switch(typeof e){case"string":if(3<e.length){if(-1<t.objectMap[e]||t.values.length>=t.maxValues)return;let s=t.get(e);if(s)2==++s.count&&t.values.push(e);else if(t.set(e,{count:1}),t.samplingPackedValues){let s=t.samplingPackedValues.get(e);s?s.count++:t.samplingPackedValues.set(e,{count:1})}}break;case"object":if(e)if(e instanceof Array)for(let s=0,n=e.length;s<n;s++)M(e[s],t);else{let n=!t.encoder.useRecords;for(var s in e)e.hasOwnProperty(s)&&(n&&M(s,t),M(e[s],t))}break;case"function":console.log(e);}}function S(e,t){// the big endian equivalents are 4 less
return!Le&&1<t&&(e-=4),{tag:e,encode:function(e,t){let s=e.byteLength,n=e.byteOffset||0,a=e.buffer||e;t(Re?Buffer.from(a,n,s):new Uint8Array(a,n,s))}}}function _(e,t){let s=e.byteLength;24>s?Ie[Ae++]=64+s:256>s?(Ie[Ae++]=88,Ie[Ae++]=s):65536>s?(Ie[Ae++]=89,Ie[Ae++]=s>>8,Ie[Ae++]=255&s):(Ie[Ae++]=90,Ue.setUint32(Ae,s),Ae+=4),Ae+s>=Ie.length&&t(Ae+s),Ie.set(e,Ae),Ae+=s}function E(e,t){// insert the ids that need to be referenced for structured clones
let s,n=2*t.length,a=e.length-n;t.sort((e,t)=>e.offset>t.offset?1:-1);for(let s,n=0;n<t.length;n++){s=t[n],s.id=n;for(let t of s.references)e[t++]=n>>8,e[t]=255&n}for(;s=t.pop();){let t=s.offset;e.copyWithin(t+n,t,a),n-=2;let r=t+n;// http://cbor.schmorp.de/value-sharing
e[r++]=216,e[r++]=28,a=t}return e}function I(e,t){Ue.setUint32(Ce.position+e,Ae-Ce.position-e+1);// the offset to bundle
let s=Ce;Ce=null,t(s[0]),t(s[1])}function U(e){if(e.Class){if(!e.encode)throw new Error("Extension has no encode function");Oe.unshift(e.Class),ke.unshift(e)}O(e)}function*v(e,t){const s=new xe(t);for(const n of e)yield s.encode(n)}async function*A(e,t){const s=new xe(t);for await(const n of e)yield s.encode(n)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - Decoder options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */let C;try{C=new TextDecoder}catch(e){}let V,x,B=0;const L=57342,D=57343,P=57337,j=6,w={};let T,F,K,Y,N,W,z,q={},G=0,H=0,J=[],$=[],Q={useRecords:!1,mapsAsObjects:!0},X=!1;class Z{constructor(e){if(e&&((e.keyMap||e._keyMap)&&!e.useRecords&&(e.useRecords=!1,e.mapsAsObjects=!0),!1===e.useRecords&&void 0===e.mapsAsObjects&&(e.mapsAsObjects=!0),e.getStructures&&(e.getShared=e.getStructures),e.getShared&&!e.structures&&((e.structures=[]).uninitialized=!0),e.keyMap))// this is what we use to denote an uninitialized structures
{this.mapKey=new Map;for(let[t,s]of Object.entries(e.keyMap))this.mapKey.set(s,t)}Object.assign(this,e)}/*
		decodeKey(key) {
			return this.keyMap
				? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
				: key
		}
		*/decodeKey(e){return this.keyMap?this.mapKey.get(e)||e:e}encodeKey(e){return this.keyMap&&this.keyMap.hasOwnProperty(e)?this.keyMap[e]:e}encodeKeys(e){if(!this._keyMap)return e;let t=new Map;for(let[s,n]of Object.entries(e))t.set(this._keyMap.hasOwnProperty(s)?this._keyMap[s]:s,n);return t}decodeKeys(e){if(!this._keyMap||"Map"!=e.constructor.name)return e;if(!this._mapKey){this._mapKey=new Map;for(let[e,t]of Object.entries(this._keyMap))this._mapKey.set(t,e)}let t={};//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)
return e.forEach((e,s)=>t[this._mapKey.has(s)?this._mapKey.get(s):s]=e),t}mapDecode(e){let t=this.decode(e);if(this._keyMap)//Experiemntal support for Optimised KeyMap  decoding 
switch(t.constructor.name){case"Array":return t.map(e=>this.decodeKeys(e));//case 'Map': return this.decodeKeys(res)
}return t}decode(e,t){if(V)// re-entrant execution, save the state and restore it after we do this decode
return b(()=>(k(),this?this.decode(e,t):Z.prototype.decode.call(Q,e,t)));x=-1<t?t:e.length,B=0,H=0,F=null,K=null,V=e;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{W=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(V=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof Z){if(q=this,N=this.sharedValues&&(this.pack?Array(this.maxPrivatePackedValues||16).concat(this.sharedValues):this.sharedValues),this.structures)return T=this.structures,a();(!T||0<T.length)&&(T=[])}else q=Q,(!T||0<T.length)&&(T=[]),N=null;return a()}decodeMultiple(e,t){let s,n=0;try{let r=e.length;X=!0;let i=this?this.decode(e,r):pe.decode(e,r);if(t){if(!1===t(i))return;for(;B<r;)if(n=B,!1===t(a()))return}else{for(s=[i];B<r;)n=B,s.push(a());return s}}catch(e){throw e.lastPosition=n,e.values=s,e}finally{X=!1,k()}}}const ee=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;let te=o,se=String.fromCharCode,ne=Array(4096);class ae{constructor(e,t){this.value=e,this.tag=t}}let re="object"==typeof self?self:global;J[0]=e=>new Date(e),J[1]=e=>new Date(s(1e3*e)),J[2]=e=>{// bigint extension
let t=BigInt(0);for(let s=0,n=e.byteLength;s<n;s++)t=BigInt(e[s])+t<<BigInt(8);return t},J[3]=e=>BigInt(-1)-J[2](e),J[4]=e=>+(e[1]+"e"+e[0]),J[5]=e=>e[1]*n(e[0]*t(2));// the registration of the record definition extension
const ie=e=>{let t=e[0]-57344,s=e[1],n=T[t];n&&n.isShared&&((T.restoreStructures||(T.restoreStructures=[]))[t]=n),T[t]=s,s.read=i(s);let a={};if(q.keyMap)for(let t,n=2,r=e.length;n<r;n++)t=q.decodeKey(s[n-2]),a[t]=e[n];else for(let t,n=2,r=e.length;n<r;n++)t=s[n-2],a[t]=e[n];return a};J[105]=ie,J[14]=e=>K?K[0].slice(K.position0,K.position0+=e):new ae(e,14),J[15]=e=>K?K[1].slice(K.position1,K.position1+=e):new ae(e,15),J[27]=e=>(re[e[0]]||Error)(e[1],e[2]);const oe=e=>{if(132!=V[B++])throw new Error("Packed values structure must be followed by a 4 element array");let t=e();// packed values
return N=N?t.concat(N.slice(t.length)):t,N.prefixes=e(),N.suffixes=e(),e();// read the rump
};oe.handlesRead=!0,J[51]=oe,J[j]=e=>{// packed reference
if(!N)if(q.getShared)m();else return new ae(e,j);if("number"==typeof e)return N[16+(0<=e?2*e:-2*e-1)];throw new Error("No support for non-integer packed references yet")},J[25]=e=>stringRefs[e],J[256]=e=>{stringRefs=[];try{return e()}finally{stringRefs=null}},J[256].handlesRead=!0,J[28]=e=>{Y||(Y=new Map,Y.id=0);let t,s=Y.id++,n=V[B];t=4==n>>5?[]:{};let a={target:t};// a placeholder object
Y.set(s,a);let r=e();// read the next value as the target object to id
return a.used?Object.assign(t,r):(a.target=r,r);// no cycle, can just use the returned read object
},J[28].handlesRead=!0,J[29]=e=>{// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)
let t=Y.get(e);return t.used=!0,t.target},J[258]=e=>new Set(e),(J[259]=e=>(q.mapsAsObjects&&(q.mapsAsObjects=!1,z=!0),e())).handlesRead=!0;$.push((e,t)=>225<=e&&255>=e?p(f().prefixes[e-224],t):28704<=e&&32767>=e?p(f().prefixes[e-28672],t):1879052288<=e&&2147483647>=e?p(f().prefixes[e-1879048192],t):216<=e&&223>=e?p(t,f().suffixes[e-216]):27647<=e&&28671>=e?p(t,f().suffixes[e-27639]):1811940352<=e&&1879048191>=e?p(t,f().suffixes[e-1811939328]):e==1399353956?{packedValues:N,structures:T.slice(0),version:t}:55799==e?t:void 0);const de=1==new Uint8Array(new Uint16Array([1]).buffer)[0],ue=["Uint8","Uint8Clamped","Uint16","Uint32","BigUint64","Int8","Int16","Int32","BigInt64","Float32","Float64"],ce=[64,68,69,70,71,72,77,78,79,85,86];for(let t=0;t<ue.length;t++)g(ue[t],ce[t]);const le=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let t=0;256>t;t++)le[t]=+("1e"+Math.floor(45.15-.30103*t));let pe=new Z({useRecords:!1});const fe=pe.decode,ge=pe.decodeMultiple,he={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let ye,me=new Float32Array(1),be=new Uint8Array(me.buffer,0,4);try{ye=new TextEncoder}catch(e){}let ke,Oe;const Re="undefined"!=typeof Buffer,Me=Re?Buffer.allocUnsafeSlow:Uint8Array,Se=Re?Buffer:Uint8Array,_e=256,Ee=Re?4294967296:2144337920;let Ie,Ue,ve,Ae=0,Ce=null;const Ve=Symbol("record-id");class xe extends Z{constructor(e){super(e),this.offset=0;let t,n,a,r,i;e=e||{};let o=Se.prototype.utf8Write?function(e,t,s){return Ie.utf8Write(e,t,s)}:!!(ye&&ye.encodeInto)&&function(e,t){return ye.encodeInto(e,Ie.subarray(t)).written},d=this,u=e.structures||e.saveStructures,c=e.maxSharedStructures;if(null==c&&(c=u?128:0),8190<c)throw new Error("Maximum maxSharedStructure is 8190");let l=e.sequential;l&&(c=0),this.structures||(this.structures=[]),this.saveStructures&&(this.saveShared=this.saveStructures);let p,f,g,h=e.sharedValues;if(h){g=Object.create(null);for(let e=0,t=h.length;e<t;e++)g[h[e]]=e}let y=[],m=0,b=0;this.mapEncode=function(e,t){// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)
if(this._keyMap&&!this._mapped)//console.log('encoding ', value)
switch(e.constructor.name){case"Array":e=e.map(e=>this.encodeKeys(e));//case 'Map': 
//	value = this.encodeKeys(value)
//	break
}//this._mapped = true
return this.encode(e,t)},this.encode=function(s,o){if(Ie||(Ie=new Me(8192),Ue=new DataView(Ie.buffer,0,8192),Ae=0),ve=Ie.length-10,2048>ve-Ae?(Ie=new Me(Ie.length),Ue=new DataView(Ie.buffer,0,Ie.length),ve=Ie.length-10,Ae=0):o===Ke&&(Ae=2147483640&Ae+7),t=Ae,d.useSelfDescribedHeader&&(Ue.setUint32(Ae,3654940416),Ae+=3),i=d.structuredClone?new Map:null,d.bundleStrings&&"string"!=typeof s?(Ce=[],Ce.size=1/0):Ce=null,n=d.structures,n){if(n.uninitialized){let e=d.getShared()||{};d.structures=n=e.structures||[],d.sharedVersion=e.version;let t=d.sharedValues=e.packedValues;if(t){g={};for(let e=0,s=t.length;e<s;e++)g[t[e]]=e}}let e=n.length;if(e>c&&!l&&(e=c),!n.transitions){n.transitions=Object.create(null);for(let t,s=0;s<e;s++){//console.log('shared struct keys:', keys)
if(t=n[s],!t)continue;let e,a=n.transitions;for(let n=0,r=t.length;n<r;n++){void 0===a[Ve]&&(a[Ve]=s);let r=t[n];e=a[r],e||(e=a[r]=Object.create(null)),a=e}a[Ve]=1048576|s}}l||(n.nextId=e)}if(a&&(a=!1),r=n||[],f=g,e.pack){let t=new Map;if(t.values=[],t.encoder=d,t.maxValues=e.maxPrivatePackedValues||(g?16:1/0),t.objectMap=g||!1,t.samplingPackedValues=p,M(s,t),0<t.values.length){Ie[Ae++]=216,Ie[Ae++]=51,R(4);let e=t.values;k(e),R(0),R(0),f=Object.create(g||null);for(let t=0,s=e.length;t<s;t++)f[e[t]]=t}}try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(k(s),Ce&&I(t,k),d.offset=Ae,i&&i.idsToInsert){Ae+=2*i.idsToInsert.length,Ae>ve&&S(Ae),d.offset=Ae;let e=E(Ie.subarray(t,Ae),i.idsToInsert);return i=null,e}return o&Ke?(Ie.start=t,Ie.end=Ae,Ie):Ie.subarray(t,Ae);// position can change if we call encode again in saveShared, so we get the buffer now
}finally{if(n)if(10>b&&b++,n.length>c&&(n.length=c),1e4<m)n.transitions=null,b=0,m=0,0<y.length&&(y=[]);else if(0<y.length&&!l){for(let e=0,t=y.length;e<t;e++)y[e][Ve]=void 0;y=[]}if(a&&d.saveShared){d.structures.length>c&&(d.structures=d.structures.slice(0,c));// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let e=Ie.subarray(t,Ae);return!1===d.updateSharedData()?d.encode(s):e;// re-encode if it fails
}o&Ye&&(Ae=t)}},this.findCommonStringsToPack=()=>(p=new Map,g||(g=Object.create(null)),e=>{let t=e&&e.threshold||4,s=this.pack?e.maxPrivatePackedValues||16:0;h||(h=this.sharedValues=[]);for(let[n,r]of p)r.count>t&&(g[n]=s++,h.push(n),a=!0);for(;this.saveShared&&!1===this.updateSharedData(););p=null});const k=s=>{Ae>ve&&(Ie=S(Ae));var n,a=typeof s;if("string"==a){if(f){let t=f[s];if(0<=t)return void(16>t?Ie[Ae++]=t+224:(Ie[Ae++]=198,1&t?k(15-t>>1):k(t-16>>1)));/*						} else if (packedStatus.serializationId != serializationId) {
								packedStatus.serializationId = serializationId
								packedStatus.count = 1
								if (options.sharedPack) {
									let sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1
									if (shareCount > (options.sharedPack.threshold || 5)) {
										let sharedPosition = packedStatus.position = packedStatus.nextSharedPosition
										hasSharedUpdate = true
										if (sharedPosition < 16)
											target[position++] = sharedPosition + 0xc0

									}
								}
							} // else any in-doc incrementation?*/if(p&&!e.pack){let e=p.get(s);e?e.count++:p.set(s,{count:1})}}let a=s.length;if(Ce&&4<=a&&1024>a){if((Ce.size+=a)>61440){let e,s=(Ce[0]?3*Ce[0].length+Ce[1].length:0)+10;Ae+s>ve&&(Ie=S(Ae+s)),Ie[Ae++]=217,Ie[Ae++]=223,Ie[Ae++]=249,Ie[Ae++]=Ce.position?132:130,Ie[Ae++]=26,e=Ae-t,Ae+=4,Ce.position&&I(t,k),Ce=["",""],Ce.size=0,Ce.position=e}let e=/[\u0080-\uFFFF]/.test(s);return Ce[e?0:1]+=s,Ie[Ae++]=e?206:207,void k(a)}let r=32>a?1:256>a?2:65536>a?3:5;// first we estimate the header size, so we can write to the correct location
let i=3*a;if(Ae+i>ve&&(Ie=S(Ae+i)),64>a||!o){let e,t,i,o=Ae+r;for(e=0;e<a;e++)t=s.charCodeAt(e),128>t?Ie[o++]=t:2048>t?(Ie[o++]=192|t>>6,Ie[o++]=128|63&t):55296==(64512&t)&&56320==(64512&(i=s.charCodeAt(e+1)))?(t=65536+((1023&t)<<10)+(1023&i),e++,Ie[o++]=240|t>>18,Ie[o++]=128|63&t>>12,Ie[o++]=128|63&t>>6,Ie[o++]=128|63&t):(Ie[o++]=224|t>>12,Ie[o++]=128|63&t>>6,Ie[o++]=128|63&t);n=o-Ae-r}else n=o(s,Ae+r,i);24>n?Ie[Ae++]=96|n:256>n?(2>r&&Ie.copyWithin(Ae+2,Ae+1,Ae+1+n),Ie[Ae++]=120,Ie[Ae++]=n):65536>n?(3>r&&Ie.copyWithin(Ae+3,Ae+2,Ae+2+n),Ie[Ae++]=121,Ie[Ae++]=n>>8,Ie[Ae++]=255&n):(5>r&&Ie.copyWithin(Ae+5,Ae+3,Ae+3+n),Ie[Ae++]=122,Ue.setUint32(Ae,n),Ae+=4),Ae+=n}else if("number"===a){if(s>>>0===s)24>s?Ie[Ae++]=s:256>s?(Ie[Ae++]=24,Ie[Ae++]=s):65536>s?(Ie[Ae++]=25,Ie[Ae++]=s>>8,Ie[Ae++]=255&s):(Ie[Ae++]=26,Ue.setUint32(Ae,s),Ae+=4);else if(s>>0===s)-24<=s?Ie[Ae++]=31-s:-256<=s?(Ie[Ae++]=56,Ie[Ae++]=~s):-65536<=s?(Ie[Ae++]=57,Ue.setUint16(Ae,~s),Ae+=2):(Ie[Ae++]=58,Ue.setUint32(Ae,~s),Ae+=4);else{let e;if(0<(e=this.useFloat32)&&4294967296>s&&-2147483648<=s){Ie[Ae++]=250,Ue.setFloat32(Ae,s);let t;if(4>e||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(t=s*le[(127&Ie[Ae])<<1|Ie[Ae+1]>>7])>>0===t)return void(Ae+=4);// move back into position for writing a double
Ae--}Ie[Ae++]=251,Ue.setFloat64(Ae,s),Ae+=8}}else if("object"===a){if(!s)Ie[Ae++]=246;else{if(i){let e=i.get(s);if(e){// 16-bit uint
if(Ie[Ae++]=216,Ie[Ae++]=29,Ie[Ae++]=25,!e.references){let t=i.idsToInsert||(i.idsToInsert=[]);e.references=[],t.push(e)}// TODO: also support 32-bit
return e.references.push(Ae-t),void(Ae+=2)}i.set(s,{offset:Ae-t})}let e=s.constructor;if(e===Object)O(s,!0);else if(e===Array){n=s.length,24>n?Ie[Ae++]=128|n:R(n);for(let e=0;e<n;e++)k(s[e])}else if(e!==Map){for(let e,t=0,n=ke.length;t<n;t++)if(e=Oe[t],s instanceof e){let e=ke[t],n=e.tag;return null==n&&(n=e.getTag&&e.getTag(s)),24>n?Ie[Ae++]=192|n:256>n?(Ie[Ae++]=216,Ie[Ae++]=n):65536>n?(Ie[Ae++]=217,Ie[Ae++]=n>>8,Ie[Ae++]=255&n):-1<n&&(Ie[Ae++]=218,Ue.setUint32(Ae,n),Ae+=4),void e.encode.call(this,s,k,S)}if(s[Symbol.iterator]){Ie[Ae++]=159;// indefinite length array
for(let e of s)k(e);// stop-code
return void(Ie[Ae++]=255)}// no extension found, write as object
O(s,!s.hasOwnProperty)}else if((this.mapsAsObjects?!1!==this.useTag259ForMaps:this.useTag259ForMaps)&&(Ie[Ae++]=217,Ie[Ae++]=1,Ie[Ae++]=3),n=s.size,24>n?Ie[Ae++]=160|n:256>n?(Ie[Ae++]=184,Ie[Ae++]=n):65536>n?(Ie[Ae++]=185,Ie[Ae++]=n>>8,Ie[Ae++]=255&n):(Ie[Ae++]=186,Ue.setUint32(Ae,n),Ae+=4),d.keyMap)for(let[e,t]of s)k(d.encodeKey(e)),k(t);else for(let[e,t]of s)k(e),k(t)}}else if("boolean"===a)Ie[Ae++]=s?245:244;else if("bigint"===a){if(s<BigInt(1)<<BigInt(64)&&0<=s)Ie[Ae++]=27,Ue.setBigUint64(Ae,s);else if(s>-(BigInt(1)<<BigInt(64))&&0>s)Ie[Ae++]=59,Ue.setBigUint64(Ae,-s-BigInt(1));else// overflow
if(this.largeBigIntToFloat)Ie[Ae++]=251,Ue.setFloat64(Ae,+s);else throw new RangeError(s+" was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");Ae+=8}else if("undefined"===a)Ie[Ae++]=247;else throw new Error("Unknown type: "+a)},O=!1===this.useRecords?this.variableMapSize?e=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let t=Object.keys(e),s=Object.values(e),n=t.length;if(24>n?Ie[Ae++]=160|n:256>n?(Ie[Ae++]=184,Ie[Ae++]=n):65536>n?(Ie[Ae++]=185,Ie[Ae++]=n>>8,Ie[Ae++]=255&n):(Ie[Ae++]=186,Ue.setUint32(Ae,n),Ae+=4),d.keyMap)for(let e=0;e<n;e++)k(encodeKey(t[e])),k(s[e]);else for(let e=0;e<n;e++)k(t[e]),k(s[e])}:(e,s)=>{Ie[Ae++]=185;// always use map 16, so we can preallocate and set the length afterwards
let n=Ae-t;Ae+=2;let a=0;if(d.keyMap)for(let t in e)(s||e.hasOwnProperty(t))&&(k(d.encodeKey(t)),k(e[t]),a++);else for(let t in e)(s||e.hasOwnProperty(t))&&(k(t),k(e[t]),a++);Ie[n++ +t]=a>>8,Ie[n+t]=255&a}:(e,t)=>{let s,n,o,d=r.transitions||(r.transitions=Object.create(null)),u=0,l=0;if(this.keyMap){o=Object.keys(e).map(e=>this.encodeKey(e)),l=o.length;for(let e,t=0;t<l;t++)e=o[t],s=d[e],s||(s=d[e]=Object.create(null),u++),d=s}else for(let a in e)(t||e.hasOwnProperty(a))&&(s=d[a],s||(1048576&d[Ve]&&(n=65535&d[Ve]),s=d[a]=Object.create(null),u++),d=s,l++);let p=d[Ve];if(void 0!==p)p&=65535,Ie[Ae++]=217,Ie[Ae++]=224|p>>8,Ie[Ae++]=255&p;else if(o||(o=d.__keys__||(d.__keys__=Object.keys(e))),void 0===n?(p=r.nextId++,!p&&(p=0,r.nextId=1),p>=_e&&(r.nextId=(p=c)+1)):p=n,r[p]=o,p<c){Ie[Ae++]=217,Ie[Ae++]=224|p>>8,Ie[Ae++]=255&p,d=r.transitions;for(let e=0;e<l;e++)(void 0===d[Ve]||1048576&d[Ve])&&(d[Ve]=p),d=d[o[e]];d[Ve]=1048576|p,a=!0}else{d[Ve]=p,Ue.setUint32(Ae,3655335680),Ae+=3,u&&(m+=b*u),y.length>=_e-c&&(y.shift()[Ve]=void 0),y.push(d),R(l+2),k(57344+p),k(o);for(let t of Object.values(e))k(t);return}for(let s in 24>l?Ie[Ae++]=128|l:R(l),e)(t||e.hasOwnProperty(s))&&k(e[s])},S=e=>{var n=Math.min,a=Math.max;let r;if(16777216<e){// special handling for really large buffers
if(e-t>Ee)throw new Error("Encoded buffer would be larger than maximum buffer size");r=n(Ee,4096*s(a((e-t)*(67108864<e?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
r=(a(e-t<<2,Ie.length-1)>>12)+1<<12;let i=new Me(r);return Ue=new DataView(i.buffer,0,r),Ie.copy?Ie.copy(i,0,t,e):i.set(Ie.slice(t,e)),Ae-=t,t=0,ve=i.length-10,Ie=i}}useBuffer(e){// this means we are finished using our own buffer and we can write over it safely
Ie=e,Ue=new DataView(Ie.buffer,Ie.byteOffset,Ie.byteLength),Ae=0}clearSharedData(){this.structures&&(this.structures=[]),this.sharedValues&&(this.sharedValues=void 0)}updateSharedData(){let e=this.sharedVersion||0;this.sharedVersion=e+1;let t=this.structures.slice(0),s=new Be(t,this.sharedValues,this.sharedVersion),n=this.saveShared(s,t=>(t&&t.version||0)==e);// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data
return!1===n?(s=this.getShared()||{},this.structures=s.structures||[],this.sharedValues=s.packedValues,this.sharedVersion=s.version,this.structures.nextId=this.structures.length):t.forEach((e,t)=>this.structures[t]=e),n}}class Be{constructor(e,t,s){this.structures=e,this.packedValues=t,this.version=s}}const Le=1==new Uint8Array(new Uint16Array([1]).buffer)[0];Oe=[Date,Set,Error,RegExp,ae,ArrayBuffer,Se,Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,"undefined"==typeof BigUint64Array?function(){}:BigUint64Array,Int8Array,Int16Array,Int32Array,"undefined"==typeof BigInt64Array?function(){}:BigInt64Array,Float32Array,Float64Array,Be],ke=[{tag:1,encode(e){let t=e.getTime()/1e3;(this.useTimestamp32||0===e.getMilliseconds())&&0<=t&&4294967296>t?(Ie[Ae++]=26,Ue.setUint32(Ae,t),Ae+=4):(Ie[Ae++]=251,Ue.setFloat64(Ae,t),Ae+=8)}},{tag:258,// https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
encode(e,t){let s=Array.from(e);t(s)}},{tag:27,// http://cbor.schmorp.de/generic-object
encode(e,t){t([e.name,e.message])}},{tag:27,// http://cbor.schmorp.de/generic-object
encode(e,t){t(["RegExp",e.source,e.flags])}},{getTag(e){return e.tag},encode(e,t){t(e.value)}},{encode(e,t,s){_(e,s)}},{encode(e,t,s){_(e,s)}},S(64,1),S(68,1),S(69,2),S(70,4),S(71,8),S(72,1),S(77,2),S(78,4),S(79,8),S(85,4),S(86,8),{encode(e,t){// write SharedData
let s=e.packedValues||[],n=e.structures||[];if(0<s.values.length){Ie[Ae++]=216,Ie[Ae++]=51,R(4);let e=s.values;t(e),R(0),R(0),packedObjectMap=Object.create(sharedPackedObjectMap||null);for(let t=0,s=e.length;t<s;t++)packedObjectMap[e[t]]=t}if(n){Ue.setUint32(Ae,3655335424),Ae+=3;let s=n.slice(0);s.unshift(57344),s.push(new ae(e.version,1399353956)),t(s)}else t(new ae(e.version,1399353956))}}];let De=new xe({useRecords:!1});const Pe=De.encode,{NEVER:je,ALWAYS:we,DECIMAL_ROUND:Te,DECIMAL_FIT:Fe}=he,Ke=512,Ye=1024;e.ALWAYS=we,e.DECIMAL_FIT=Fe,e.DECIMAL_ROUND=Te,e.Decoder=Z,e.Encoder=xe,e.FLOAT32_OPTIONS=he,e.NEVER=je,e.REUSE_BUFFER_MODE=Ke,e.Tag=ae,e.addExtension=U,e.clearSource=k,e.decode=fe,e.decodeIter=function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const s=new Z(t);let n;const a=e=>{let t;// if there's incomplete data from previous chunk, concatinate and try again
n&&(e=Buffer.concat([n,e]),n=void 0);try{t=s.decodeMultiple(e)}catch(s){if(s.incomplete)n=e.slice(s.lastPosition),t=s.values;else throw s}return t};if("function"==typeof e[Symbol.iterator])return function*(){for(const t of e)yield*a(t)}();return"function"==typeof e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*a(t)}():void 0},e.decodeMultiple=ge,e.encode=Pe,e.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - cbor-x Encoder options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof e[Symbol.iterator])return v(e,t);if("function"==typeof e.then||"function"==typeof e[Symbol.asyncIterator])return A(e,t);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},e.isNativeAccelerationEnabled=!1,e.roundFloat32=function(e){me[0]=e;let t=le[(127&be[3])<<1|be[2]>>7];return(t*e+(0<e?.5:-.5)>>0)/t},Object.defineProperty(e,"__esModule",{value:!0})});
