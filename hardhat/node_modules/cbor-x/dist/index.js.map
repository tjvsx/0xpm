{"version":3,"sources":["webpack://CBOR/webpack/universalModuleDefinition","webpack://CBOR/webpack/bootstrap","webpack://CBOR/./encode.js","webpack://CBOR/./decode.js","webpack://CBOR/./browser.js","webpack://CBOR/(webpack)/buildin/global.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","decoderModule","Decoder","mult10","typedArrays","textEncoder","extensions","extensionClasses","TextEncoder","error","hasNodeBuffer","Buffer","ByteArrayAllocate","allocUnsafeSlow","Uint8Array","ByteArray","target","targetView","safeEnd","position","RECORD_SYMBOL","copyBinary","source","targetOffset","offset","endOffset","writeExtBuffer","typedArray","type","encode","length","byteLength","byteOffset","buffer","from","writeBuffer","setUint32","copy","Encoder","options","start","sharedStructures","hasSharedUpdate","structures","referenceMap","super","this","lastSharedStructuresLength","encodeUtf8","utf8Write","string","maxBytes","encodeInto","subarray","written","encoder","maxSharedStructures","isSequential","sequential","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","Error","DataView","structuredClone","Map","uninitialized","getStructures","sharedStructuresLength","transitions","keys","nextTransition","transition","nextId","idsToInsert","makeRoom","serialized","distanceToMove","lastEnd","sort","a","b","pop","id","copyWithin","insertIds","saveStructures","slice","headerSize","strLength","c1","c2","strPosition","charCodeAt","setUint16","useFloat32","xShifted","setFloat32","setFloat64","referee","push","set","constructor","writeObject","Array","size","entryValue","extension","tag","useRecords","variableMapSize","safePrototype","objectOffset","newTransitions","recordId","shift","concat","end","newSize","Math","max","newBuffer","Date","Set","RegExp","ArrayBuffer","getPrototypeOf","date","seconds","getTime","useTimestamp32","getMilliseconds","message","regex","flags","arrayBuffer","indexOf","addExtension","Class","unshift","decoder","src","srcEnd","TextDecoder","EMPTY_ARRAY","srcString","dataView","currentStructures","strings","stringPosition","currentDecoder","srcStringStart","srcStringEnd","currentExtensions","defaultOptions","mapsAsObjects","undefined","assign","continueReading","saveState","decode","read","token","majorType","val","byte0","byte1","half","exp","mant","Infinity","NaN","getFloat16","getUint16","getFloat32","multiplier","getUint32","getFloat64","uint64AsNumber","getBigUint64","copyBuffers","shortStringInJS","readFixedString","array","map","structure","createStructureReader","updatedStructures","splice","apply","isNaN","incomplete","getPosition","validName","readObject","count","Function","test","JSON","stringify","join","readStringJS","readString8","readString16","readString32","result","units","byte2","byte3","unit","fromCharCode","String","setExtractor","extractStrings","readString","headerLength","srcStringLength","e","f","g","h","j","k","glbl","global","dateString","epochSec","BigInt","data","refEntry","targetProperties","used","callback","savedSrcEnd","savedPosition","savedStringPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedStrings","savedReferenceMap","savedSrc","savedStructures","savedDecoder","typeCode","typedArrayName","clearSource","floor","ALWAYS","DECIMAL_ROUND","DECIMAL_FIT"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CBOR\"] = factory();\n\telse\n\t\troot[\"CBOR\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","\"use strict\"\r\nlet decoderModule = require('./decode')\r\nlet Decoder = decoderModule.Decoder\r\nlet mult10 = decoderModule.mult10\r\nconst typedArrays = decoderModule.typedArrays\r\nlet textEncoder\r\ntry {\r\n\ttextEncoder = new TextEncoder()\r\n} catch (error) {}\r\nlet extensions, extensionClasses\r\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\r\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\r\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\r\nlet target\r\nlet targetView\r\nlet position = 0\r\nlet safeEnd\r\nconst RECORD_SYMBOL = Symbol('record-id')\r\nclass Encoder extends Decoder {\r\n\tconstructor(options) {\r\n\t\tsuper(options)\r\n\t\tthis.offset = 0\r\n\t\tlet typeBuffer\r\n\t\tlet start\r\n\t\tlet sharedStructures\r\n\t\tlet hasSharedUpdate\r\n\t\tlet structures\r\n\t\tlet referenceMap\r\n\t\tlet lastSharedStructuresLength = 0\r\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\r\n\t\t\treturn target.utf8Write(string, position, maxBytes)\r\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\r\n\t\t\tfunction(string, position) {\r\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\r\n\t\t\t} : false\r\n\r\n\t\tlet encoder = this\r\n\t\tlet maxSharedStructures = 64\r\n\t\tlet isSequential = options && options.sequential\r\n\t\tif (isSequential) {\r\n\t\t\tmaxSharedStructures = 0\r\n\t\t\tthis.structures = []\r\n\t\t}\r\n\t\tlet recordIdsToRemove = []\r\n\t\tlet transitionsCount = 0\r\n\t\tlet serializationsSinceTransitionRebuild = 0\r\n\t\tif (this.structures && this.structures.length > maxSharedStructures) {\r\n\t\t\tthrow new Error('Too many shared structures')\r\n\t\t}\r\n\r\n\t\tthis.encode = function(value) {\r\n\t\t\tif (!target) {\r\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\r\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\r\n\t\t\t\tposition = 0\r\n\t\t\t}\r\n\t\t\tsafeEnd = target.length - 10\r\n\t\t\tif (safeEnd - position < 0x800) {\r\n\t\t\t\t// don't start too close to the end, \r\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\r\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\r\n\t\t\t\tsafeEnd = target.length - 10\r\n\t\t\t\tposition = 0\r\n\t\t\t}\r\n\t\t\tstart = position\r\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\r\n\t\t\tsharedStructures = encoder.structures\r\n\t\t\tif (sharedStructures) {\r\n\t\t\t\tif (sharedStructures.uninitialized)\r\n\t\t\t\t\tencoder.structures = sharedStructures = encoder.getStructures()\r\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\r\n\t\t\t\tif (sharedStructuresLength >  maxSharedStructures && !isSequential)\r\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\r\n\t\t\t\tif (!sharedStructures.transitions) {\r\n\t\t\t\t\t// rebuild our structure transitions\r\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\r\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\r\n\t\t\t\t\t\tlet keys = sharedStructures[i]\r\n\t\t\t\t\t\tif (!keys)\r\n\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\r\n\t\t\t\t\t\tfor (let i =0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\tlet key = keys[i]\r\n\t\t\t\t\t\t\tnextTransition = transition[key]\r\n\t\t\t\t\t\t\tif (!nextTransition) {\r\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttransition = nextTransition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastSharedStructuresLength = sharedStructures.length\r\n\t\t\t\t}\r\n\t\t\t\tif (!isSequential)\r\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength + 0x40\r\n\t\t\t}\r\n\t\t\tif (hasSharedUpdate)\r\n\t\t\t\thasSharedUpdate = false\r\n\t\t\tstructures = sharedStructures || []\r\n\t\t\ttry {\r\n\t\t\t\tencode(value)\r\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\r\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\r\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 6\r\n\t\t\t\t\tif (position > safeEnd)\r\n\t\t\t\t\t\tmakeRoom(position)\r\n\t\t\t\t\tencoder.offset = position\r\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\r\n\t\t\t\t\treferenceMap = null\r\n\t\t\t\t\treturn serialized\r\n\t\t\t\t}\r\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveStructures, so we get the buffer now\r\n\t\t\t} finally {\r\n\t\t\t\tif (sharedStructures) {\r\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\r\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\r\n\t\t\t\t\tif (transitionsCount > 10000) {\r\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\r\n\t\t\t\t\t\tsharedStructures.transitions = null\r\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\r\n\t\t\t\t\t\ttransitionsCount = 0\r\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\r\n\t\t\t\t\t\t\trecordIdsToRemove = []\r\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\r\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\r\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trecordIdsToRemove = []\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (hasSharedUpdate && encoder.saveStructures) {\r\n\t\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\r\n\t\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (encoder.saveStructures(encoder.structures, lastSharedStructuresLength) === false) {\r\n\t\t\t\t\t\t\t// get updated structures and try again if the update failed\r\n\t\t\t\t\t\t\tencoder.structures = encoder.getStructures() || []\r\n\t\t\t\t\t\t\treturn encoder.encode(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlastSharedStructuresLength = encoder.structures.length\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst encode = (value) => {\r\n\t\t\tif (position > safeEnd)\r\n\t\t\t\ttarget = makeRoom(position)\r\n\r\n\t\t\tvar type = typeof value\r\n\t\t\tvar length\r\n\t\t\tif (type === 'string') {\r\n\t\t\t\tlet strLength = value.length\r\n\t\t\t\tlet headerSize\r\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\r\n\t\t\t\tif (strLength < 0x20) {\r\n\t\t\t\t\theaderSize = 1\r\n\t\t\t\t} else if (strLength < 0x100) {\r\n\t\t\t\t\theaderSize = 2\r\n\t\t\t\t} else if (strLength < 0x10000) {\r\n\t\t\t\t\theaderSize = 3\r\n\t\t\t\t} else {\r\n\t\t\t\t\theaderSize = 5\r\n\t\t\t\t}\r\n\t\t\t\tlet maxBytes = strLength * 3\r\n\t\t\t\tif (position + maxBytes > safeEnd)\r\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\r\n\r\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\r\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\r\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\r\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\r\n\t\t\t\t\t\tif (c1 < 0x80) {\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\r\n\t\t\t\t\t\t} else if (c1 < 0x800) {\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\r\n\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\r\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\r\n\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\r\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlength = strPosition - position - headerSize\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (length < 0x18) {\r\n\t\t\t\t\ttarget[position++] = 0x60 | length\r\n\t\t\t\t} else if (length < 0x100) {\r\n\t\t\t\t\tif (headerSize < 2) {\r\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget[position++] = 0x78\r\n\t\t\t\t\ttarget[position++] = length\r\n\t\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\t\tif (headerSize < 3) {\r\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget[position++] = 0x79\r\n\t\t\t\t\ttarget[position++] = length >> 8\r\n\t\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (headerSize < 5) {\r\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget[position++] = 0x7a\r\n\t\t\t\t\ttargetView.setUint32(position, length)\r\n\t\t\t\t\tposition += 4\r\n\t\t\t\t}\r\n\t\t\t\tposition += length\r\n\t\t\t} else if (type === 'number') {\r\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\r\n\t\t\t\t\t// positive uint\r\n\t\t\t\t\tif (value < 0x18) {\r\n\t\t\t\t\t\ttarget[position++] = value\r\n\t\t\t\t\t} else if (value < 0x100) {\r\n\t\t\t\t\t\ttarget[position++] = 0x18\r\n\t\t\t\t\t\ttarget[position++] = value\r\n\t\t\t\t\t} else if (value < 0x10000) {\r\n\t\t\t\t\t\ttarget[position++] = 0x19\r\n\t\t\t\t\t\ttarget[position++] = value >> 8\r\n\t\t\t\t\t\ttarget[position++] = value & 0xff\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget[position++] = 0x1a\r\n\t\t\t\t\t\ttargetView.setUint32(position, value)\r\n\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\r\n\t\t\t\t\tif (value >= -0x18) {\r\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\r\n\t\t\t\t\t} else if (value >= -0x100) {\r\n\t\t\t\t\t\ttarget[position++] = 0x38\r\n\t\t\t\t\t\ttarget[position++] = ~value\r\n\t\t\t\t\t} else if (value >= -0x10000) {\r\n\t\t\t\t\t\ttarget[position++] = 0x39\r\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\r\n\t\t\t\t\t\tposition += 2\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttarget[position++] = 0x3a\r\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\r\n\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet useFloat32\r\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\r\n\t\t\t\t\t\ttarget[position++] = 0xfa\r\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\r\n\t\t\t\t\t\tlet xShifted\r\n\t\t\t\t\t\tif (useFloat32 < 4 ||\r\n\t\t\t\t\t\t\t// this checks for  rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\r\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\r\n\t\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget[position++] = 0xfb\r\n\t\t\t\t\ttargetView.setFloat64(position, value)\r\n\t\t\t\t\t/*if (!target[position[4] && !target[position[5] && !target[position[6] && !target[position[7] && !(target[0] & 0x78) < ) {\r\n\t\t\t\t\t\t// something like this can be represented as a float with binary rounding\r\n\t\t\t\t\t}*/\r\n\t\t\t\t\tposition += 8\r\n\t\t\t\t}\r\n\t\t\t} else if (type === 'object') {\r\n\t\t\t\tif (!value)\r\n\t\t\t\t\ttarget[position++] = 0xf6\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (referenceMap) {\r\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\r\n\t\t\t\t\t\tif (referee) {\r\n\t\t\t\t\t\t\tif (!referee.id) {\r\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\r\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttarget[position++] = 0xca // tag 10\r\n\t\t\t\t\t\t\ttarget[position++] = 0x1a // uint32\r\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\r\n\t\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t} else \r\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet constructor = value.constructor\r\n\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\twriteObject(value, true)\r\n\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\tlength = value.length\r\n\t\t\t\t\t\tif (length < 0x18) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\r\n\t\t\t\t\t\t} else if (length < 0x100) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0x98\r\n\t\t\t\t\t\t\ttarget[position++] = length\r\n\t\t\t\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0x99\r\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\r\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget[position++] = 0x9a\r\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\r\n\t\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\t\t\t\tencode(value[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (constructor === Map) {\r\n\t\t\t\t\t\tlength = value.size\r\n\t\t\t\t\t\tif (length < 0x18) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\r\n\t\t\t\t\t\t} else if (length < 0x100) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\r\n\t\t\t\t\t\t\ttarget[position++] = length\r\n\t\t\t\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\r\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\r\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget[position++] = 0xba\r\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\r\n\t\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\r\n\t\t\t\t\t\t\tencode(key)\r\n\t\t\t\t\t\t\tencode(entryValue)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\t\r\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\r\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\r\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\r\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\r\n\t\t\t\t\t\t\t\tlet tag = extension.tag\r\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\r\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\r\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\r\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\r\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\r\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\r\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\r\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\r\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\r\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\r\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xba\r\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\r\n\t\t\t\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\r\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode)\r\n\t\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// no extension found, write as object\r\n\t\t\t\t\t\twriteObject(value, false)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (type === 'boolean') {\r\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\r\n\t\t\t} else if (type === 'bigint') {\r\n\t\t\t\ttarget[position++] = 0xfb\r\n\t\t\t\t/*if (value < 9223372036854776000 && value > -9223372036854776000) \r\n\t\t\t\t\ttargetView.setBigInt64(position, value)\r\n\t\t\t\telse*/\r\n\t\t\t\t\ttargetView.setFloat64(position, value)\r\n\t\t\t\tposition += 8\r\n\t\t\t} else if (type === 'undefined') {\r\n\t\t\t\t//target[position++] = 0xc1 // this is the \"never-used\" byte\r\n\t\t\t\ttarget[position++] = 0xf7\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Unknown type ' + type)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\r\n\t\t\tlet keys = Object.keys(object)\r\n\t\t\tlet length = keys.length\r\n\t\t\tif (length < 0x18) {\r\n\t\t\t\ttarget[position++] = 0xa0 | length\r\n\t\t\t} else if (length < 0x100) {\r\n\t\t\t\ttarget[position++] = 0xb8\r\n\t\t\t\ttarget[position++] = length\r\n\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\ttarget[position++] = 0xb9\r\n\t\t\t\ttarget[position++] = length >> 8\r\n\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t} else {\r\n\t\t\t\ttarget[position++] = 0xba\r\n\t\t\t\ttargetView.setUint32(position, length)\r\n\t\t\t\tposition += 4\r\n\t\t\t}\r\n\t\t\tlet key\r\n\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\tencode(key = keys[i])\r\n\t\t\t\tencode(object[key])\r\n\t\t\t}\r\n\t\t} :\r\n\t\t(object, safePrototype) => {\r\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\r\n\t\t\tlet objectOffset = position - start\r\n\t\t\tposition += 2\r\n\t\t\tlet size = 0\r\n\t\t\tfor (let key in object) {\r\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\r\n\t\t\t\t\tencode(key)\r\n\t\t\t\t\tencode(object[key])\r\n\t\t\t\t\tsize++\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttarget[objectOffset++ + start] = size >> 8\r\n\t\t\ttarget[objectOffset + start] = size & 0xff\r\n\t\t} :\r\n\r\n\t/*\tsharedStructures ?  // For highly stable structures, using for-in can a little bit faster\r\n\t\t(object, safePrototype) => {\r\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\r\n\t\t\tlet objectOffset = position++ - start\r\n\t\t\tlet wroteKeys\r\n\t\t\tfor (let key in object) {\r\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\r\n\t\t\t\t\tnextTransition = transition[key]\r\n\t\t\t\t\tif (!nextTransition) {\r\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\r\n\t\t\t\t\t\tnextTransition.__keys__ = (transition.__keys__ || []).concat([key])\r\n\t\t\t\t\t\t/*let keys = Object.keys(object)\r\n\t\t\t\t\t\tif \r\n\t\t\t\t\t\tlet size = 0\r\n\t\t\t\t\t\tlet startBranch = transition.__keys__ ? transition.__keys__.length : 0\r\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i++) {\r\n\t\t\t\t\t\t\tlet key = keys[i]\r\n\t\t\t\t\t\t\tsize += key.length << 2\r\n\t\t\t\t\t\t\tif (i >= startBranch) {\r\n\t\t\t\t\t\t\t\tnextTransition = nextTransition[key] = Object.create(null)\r\n\t\t\t\t\t\t\t\tnextTransition.__keys__ = keys.slice(0, i + 1)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmakeRoom(position + size)\r\n\t\t\t\t\t\tnextTransition = transition[key]\r\n\t\t\t\t\t\ttarget.copy(target, )\r\n\t\t\t\t\t\tobjectOffset\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttransition = nextTransition\r\n\t\t\t\t\tencode(object[key])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet id = transition.id\r\n\t\t\tif (!id) {\r\n\t\t\t\tid = transition.id = structures.push(transition.__keys__) + 63\r\n\t\t\t\tif (sharedStructures.onUpdate)\r\n\t\t\t\t\tsharedStructures.onUpdate(id, transition.__keys__)\r\n\t\t\t}\r\n\t\t\ttarget[objectOffset + start] = id\r\n\t\t}*/\r\n\t\t(object) => {\r\n\t\t\tlet keys = Object.keys(object)\r\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\r\n\t\t\tlet newTransitions = 0\r\n\t\t\tfor (let i =0, l = keys.length; i < l; i++) {\r\n\t\t\t\tlet key = keys[i]\r\n\t\t\t\tnextTransition = transition[key]\r\n\t\t\t\tif (!nextTransition) {\r\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\r\n\t\t\t\t\tnewTransitions++\r\n\t\t\t\t}\r\n\t\t\t\ttransition = nextTransition\r\n\t\t\t}\r\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\r\n\t\t\tif (recordId) {\r\n\t\t\t\ttarget[position++] = 0xd8 // tag one byte\r\n\t\t\t\ttarget[position++] = recordId\r\n\t\t\t} else {\r\n\t\t\t\trecordId = structures.nextId++\r\n\t\t\t\tif (!recordId) {\r\n\t\t\t\t\trecordId = 0x40\r\n\t\t\t\t\tstructures.nextId = 0x41\r\n\t\t\t\t}\r\n\t\t\t\tif (recordId >= 0x100) {// cycle back around\r\n\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures + 0x40) + 1\r\n\t\t\t\t}\r\n\t\t\t\ttransition[RECORD_SYMBOL] = recordId\r\n\t\t\t\tstructures[recordId - 0x40] = keys\r\n\t\t\t\tif (sharedStructures && sharedStructures.length <= maxSharedStructures) {\r\n\t\t\t\t\ttarget[position++] = 0xd8 // tag one byte\r\n\t\t\t\t\ttarget[position++] = recordId // tag number\r\n\t\t\t\t\thasSharedUpdate = true\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttarget[position++] = 0xc6 // tag 6\r\n\t\t\t\t\tif (newTransitions)\r\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\r\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\r\n\t\t\t\t\tif (recordIdsToRemove.length >= 0xc0 - maxSharedStructures)\r\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\r\n\t\t\t\t\trecordIdsToRemove.push(transition)\r\n\t\t\t\t\tencode([ recordId ].concat(keys))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// now write the values\r\n\t\t\tfor (let i =0, l = keys.length; i < l; i++)\r\n\t\t\t\tencode(object[keys[i]])\r\n\t\t}\r\n\t\tconst makeRoom = (end) => {\r\n\t\t\tlet newSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\r\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\r\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\r\n\t\t\tif (target.copy)\r\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\r\n\t\t\telse\r\n\t\t\t\tcopyBinary(target, newBuffer, 0, start, end)\r\n\t\t\tposition -= start\r\n\t\t\tstart = 0\r\n\t\t\tsafeEnd = newBuffer.length - 10\r\n\t\t\treturn target = newBuffer\r\n\t\t}\r\n\t}\r\n\tuseBuffer(buffer) {\r\n\t\t// this means we are finished using our own buffer and we can write over it safely\r\n\t\ttarget = buffer\r\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\r\n\t\tposition = 0\r\n\t}\r\n}\r\nexports.Encoder = Encoder\r\n\r\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\r\n\twhile (offset < endOffset) {\r\n\t\ttarget[targetOffset++] = source[offset++]\r\n\t}\r\n}\r\n\r\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/ ]\r\nextensions = [{\r\n\ttag: 1,\r\n\tencode(date, encode) {\r\n\t\tlet seconds = date.getTime() / 1000\r\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\r\n\t\t\t// Timestamp 32\r\n\t\t\ttarget[position++] = 0x1a\r\n\t\t\ttargetView.setUint32(position, seconds)\r\n\t\t\tposition += 4\r\n\t\t} else {\r\n\t\t\t// Timestamp float64\r\n\t\t\ttarget[position++] = 0xfb\r\n\t\t\ttargetView.setFloat64(position, seconds)\r\n\t\t\tposition += 8\r\n\t\t}\r\n\t}\r\n}, {\r\n\ttag: 11,\r\n\tencode(set, encode) {\r\n\t\tlet array = Array.from(set)\r\n\t\tencode(array)\r\n\t}\r\n}, {\r\n\ttag: 8,\r\n\tencode(error, encode) {\r\n\t\tencode([ error.name, error.message ])\r\n\t}\r\n}, {\r\n\ttag: 13,\r\n\tencode(regex, encode) {\r\n\t\tencode([ regex.source, regex.flags ])\r\n\t}\r\n}, {\r\n\tencode(arrayBuffer, encode) {\r\n\t\tif (this.structuredClone)\r\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, encode)\r\n\t\telse\r\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer))\r\n\t}\r\n}, {\r\n\tencode(typedArray, encode) {\r\n\t\tlet constructor = typedArray.constructor\r\n\t\tif (constructor !== ByteArray && this.structuredClone)\r\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), encode)\r\n\t\telse\r\n\t\t\twriteBuffer(typedArray)\r\n\t}\r\n}]\r\n\r\nfunction writeExtBuffer(typedArray, type, encode) {\r\n\ttarget[position++] = 0xcc // tag 12\r\n\tlet length = typedArray.byteLength\r\n\tlet offset = typedArray.byteOffset || 0\r\n\tlet buffer = typedArray.buffer || typedArray\r\n\tencode([type, hasNodeBuffer ? Buffer.from(buffer, offset, length) :\r\n\t\tnew Uint8Array(buffer, offset, length)])\r\n}\r\nfunction writeBuffer(buffer) {\r\n\tlet length = buffer.byteLength\r\n\tif (length < 0x100) {\r\n\t\ttarget[position++] = 0x58\r\n\t\ttarget[position++] = length\r\n\t} else if (length < 0x10000) {\r\n\t\ttarget[position++] = 0x59\r\n\t\ttarget[position++] = length >> 8\r\n\t\ttarget[position++] = length & 0xff\r\n\t} else {\r\n\t\ttarget[position++] = 0x5a\r\n\t\ttargetView.setUint32(position, length)\r\n\t\tposition += 4\r\n\t}\r\n\tif (buffer.copy)\r\n\t\tbuffer.copy(target, position)\r\n\telse\r\n\t\tcopyBinary(buffer, target, position, 0, length)\r\n\tposition += length\r\n}\r\n\r\nfunction writeExtensionData(result, target, position, type) {\r\n\tlet length = result.length\r\n\tswitch (length) {\r\n\t\tcase 1:\r\n\t\t\ttarget[position++] = 0xd4\r\n\t\t\tbreak\r\n\t\tcase 2:\r\n\t\t\ttarget[position++] = 0xd5\r\n\t\t\tbreak\r\n\t\tcase 4:\r\n\t\t\ttarget[position++] = 0xd6\r\n\t\t\tbreak\r\n\t\tcase 8:\r\n\t\t\ttarget[position++] = 0xd7\r\n\t\t\tbreak\r\n\t\tcase 16:\r\n\t\t\ttarget[position++] = 0xd8\r\n\t\t\tbreak\r\n\t\tdefault:\r\n\t\t\tif (length < 0x100) {\r\n\t\t\t\ttarget[position++] = 0xc7\r\n\t\t\t\ttarget[position++] = length\r\n\t\t\t} else if (length < 0x10000) {\r\n\t\t\t\ttarget[position++] = 0xc8\r\n\t\t\t\ttarget[position++] = length << 8\r\n\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t} else {\r\n\t\t\t\ttarget[position++] = 0xc9\r\n\t\t\t\ttarget[position++] = length << 24\r\n\t\t\t\ttarget[position++] = (length << 16) & 0xff\r\n\t\t\t\ttarget[position++] = (length << 8) & 0xff\r\n\t\t\t\ttarget[position++] = length & 0xff\r\n\t\t\t}\r\n\t}\r\n\ttarget[position++] = type\r\n\tif (result.copy)\r\n\t\tresult.copy(target, position)\r\n\telse\r\n\t\tcopyBinary(result, target, position, 0, length)\r\n\tposition += length\r\n\treturn position\r\n}\r\n\r\nfunction insertIds(serialized, idsToInsert) {\r\n\t// insert the ids that need to be referenced for structured clones\r\n\tlet nextId\r\n\tlet distanceToMove = idsToInsert.length * 6\r\n\tlet lastEnd = serialized.length - distanceToMove\r\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\r\n\twhile (nextId = idsToInsert.pop()) {\r\n\t\tlet offset = nextId.offset\r\n\t\tlet id = nextId.id\r\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\r\n\t\tdistanceToMove -= 6\r\n\t\tlet position = offset + distanceToMove\r\n\t\tserialized[position++] = 0xc9 // tag 9\r\n\t\tserialized[position++] = 0x1a // uint32\r\n\t\tserialized[position++] = id << 24\r\n\t\tserialized[position++] = (id << 16) & 0xff\r\n\t\tserialized[position++] = (id << 8) & 0xff\r\n\t\tserialized[position++] = id & 0xff\r\n\t\tlastEnd = offset\r\n\t}\r\n\treturn serialized\r\n}\r\n\r\nexports.addExtension = function(extension) {\r\n\tif (extension.Class) {\r\n\t\tif (!extension.encode)\r\n\t\t\tthrow new Error('Extension has no encode function')\r\n\t\textensionClasses.unshift(extension.Class)\r\n\t\textensions.unshift(extension)\r\n\t}\r\n\tdecoderModule.addExtension(extension)\r\n}\r\n","\"use strict\"\r\nlet decoder\r\ntry {\r\n\tdecoder = new TextDecoder()\r\n} catch(error) {}\r\nlet src\r\nlet srcEnd\r\nlet position = 0\r\nlet alreadySet\r\nconst EMPTY_ARRAY = []\r\nlet strings = EMPTY_ARRAY\r\nlet stringPosition = 0\r\nlet currentDecoder = {}\r\nlet srcString\r\nlet srcStringStart = 0\r\nlet srcStringEnd = 0\r\nlet referenceMap\r\nlet currentExtensions = []\r\nlet dataView\r\nlet defaultOptions = {\r\n\tuseRecords: false,\r\n\tmapsAsObjects: true\r\n}\r\n\r\nclass Decoder {\r\n\tconstructor(options) {\r\n\t\tif (options) {\r\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\r\n\t\t\t\toptions.mapsAsObjects = true\r\n\t\t\tif (options.getStructures && !options.structures)\r\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\r\n\t\t}\r\n\t\tObject.assign(this, options)\r\n\t}\r\n\tdecode(source, end, continueReading) {\r\n\t\tif (src) {\r\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\r\n\t\t\treturn saveState(() => {\r\n\t\t\t\tsrc = null\r\n\t\t\t\treturn this ? this.decode(source, end, continueReading) : Decoder.prototype.decode.call(defaultOptions, source, end, continueReading)\r\n\t\t\t})\r\n\t\t}\r\n\t\tsrcEnd = end > -1 ? end : source.length\r\n\t\tposition = 0\r\n\t\tstringPosition = 0\r\n\t\tsrcStringEnd = 0\r\n\t\tsrcString = null\r\n\t\tstrings = EMPTY_ARRAY\r\n\t\tsrc = source\r\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\r\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\r\n\t\t// new ones\r\n\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\r\n\t\tif (this) {\r\n\t\t\tcurrentDecoder = this\r\n\t\t\tif (this.structures) {\r\n\t\t\t\tcurrentStructures = this.structures\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn read()\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tif (position >= srcEnd || !continueReading) {\r\n\t\t\t\t\t\t// finished reading this source, cleanup references\r\n\t\t\t\t\t\tcurrentStructures = null\r\n\t\t\t\t\t\tsrc = null\r\n\t\t\t\t\t\tif (referenceMap)\r\n\t\t\t\t\t\t\treferenceMap = null\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\r\n\t\t\t\tcurrentStructures = []\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcurrentDecoder = defaultOptions\r\n\t\t\tif (!currentStructures || currentStructures.length > 0)\r\n\t\t\t\tcurrentStructures = []\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn read()\r\n\t\t} finally {\r\n\t\t\tsrc = null\r\n\t\t\tif (referenceMap)\r\n\t\t\t\treferenceMap = null\r\n\t\t}\r\n\t}\r\n}\r\nlet currentStructures\r\nexports.Decoder = Decoder\r\nexports.read = read\r\nexports.getPosition = () => {\r\n\treturn position\r\n}\r\n\r\nfunction read() {\r\n\tlet token = src[position++]\r\n\tlet majorType = token >> 5\r\n\ttoken = token & 0x1f\r\n\tif (token > 0x17) {\r\n\t\tswitch (token) {\r\n\t\t\tcase 0x18:\r\n\t\t\t\ttoken = src[position++]\r\n\t\t\t\tbreak\r\n\t\t\tcase 0x19:\r\n\t\t\t\tif (majorType == 7) {\r\n\t\t\t\t\treturn getFloat16()\r\n\t\t\t\t}\r\n\t\t\t\ttoken = dataView.getUint16(position)\r\n\t\t\t\tposition += 2\r\n\t\t\t\tbreak\r\n\t\t\tcase 0x1a:\r\n\t\t\t\tif (majorType == 7) {\r\n\t\t\t\t\tlet value = dataView.getFloat32(position)\r\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\r\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\r\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\r\n\t\t\t\t\t\tposition += 4\r\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\r\n\t\t\t\t\t}\r\n\t\t\t\t\tposition += 4\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\ttoken = dataView.getUint32(position)\r\n\t\t\t\tposition += 4\r\n\t\t\t\tbreak\r\n\t\t\tcase 0x1b:\r\n\t\t\t\tif (majorType == 7) {\r\n\t\t\t\t\tlet value = dataView.getFloat64(position)\r\n\t\t\t\t\tposition += 8\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tif (currentDecoder.uint64AsNumber)\r\n\t\t\t\t\treturn src[position++] * 0x100000000000000 + src[position++] * 0x1000000000000 + src[position++] * 0x10000000000 + src[position++] * 0x100000000 +\r\n\t\t\t\t\t\tsrc[position++] * 0x1000000 + (src[position++] << 16) + (src[position++] << 8) + src[position++]\r\n\t\t\t\ttoken = dataView.getBigUint64(position)\r\n\t\t\t\tposition += 8\r\n\t\t\t\tbreak\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error('Unknown token ' + token)\r\n\t\t}\r\n\t}\r\n\tswitch (majorType) {\r\n\t\tcase 0: // positive int\r\n\t\t\treturn token\r\n\t\tcase 1: // negative int\r\n\t\t\treturn ~token\r\n\t\tcase 2: // buffer\r\n\t\t\treturn readBin(token)\r\n\t\tcase 3: // string\r\n\t\t\tif (srcStringEnd >= position) {\r\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\r\n\t\t\t}\r\n\t\t\tif (srcStringEnd == 0 && srcEnd < 120 && token < 16) {\r\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\r\n\t\t\t\tlet string = /*length < 16 ? */shortStringInJS(token)// : longStringInJS(length)\r\n\t\t\t\tif (string != null)\r\n\t\t\t\t\treturn string\r\n\t\t\t}\r\n\t\t\treturn readFixedString(token)\r\n\t\tcase 4: // array\r\n\t\t\tlet array = new Array(token)\r\n\t\t\tfor (let i = 0; i < token; i++) {\r\n\t\t\t\tarray[i] = read()\r\n\t\t\t}\r\n\t\t\treturn array\r\n\t\tcase 5: // map\r\n\t\t\tif (currentDecoder.mapsAsObjects) {\r\n\t\t\t\tlet object = {}\r\n\t\t\t\tfor (let i = 0; i < token; i++) {\r\n\t\t\t\t\tobject[read()] = read()\r\n\t\t\t\t}\r\n\t\t\t\treturn object\r\n\t\t\t} else {\r\n\t\t\t\tlet map = new Map()\r\n\t\t\t\tfor (let i = 0; i < token; i++) {\r\n\t\t\t\t\tmap.set(read(), read())\r\n\t\t\t\t}\r\n\t\t\t\treturn map\r\n\t\t\t}\r\n\t\tcase 6: // extension\r\n\t\t\tif (token >= 0x40 && token < 0x100) { // record structures\r\n\t\t\t\tlet structure = currentStructures[token - 0x40]\r\n\t\t\t\tif (structure) {\r\n\t\t\t\t\tif (!structure.read)\r\n\t\t\t\t\t\tstructure.read = createStructureReader(structure)\r\n\t\t\t\t\treturn structure.read()\r\n\t\t\t\t} else if (currentDecoder.getStructures) {\r\n\t\t\t\t\tlet updatedStructures = saveState(() => {\r\n\t\t\t\t\t\t// save the state in case getStructures modifies our buffer\r\n\t\t\t\t\t\tsrc = null\r\n\t\t\t\t\t\treturn currentDecoder.getStructures()\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (currentStructures === true)\r\n\t\t\t\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\r\n\t\t\t\t\tstructure = currentStructures[token - 0x40]\r\n\t\t\t\t\tif (structure) {\r\n\t\t\t\t\t\tif (!structure.read)\r\n\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\r\n\t\t\t\t\t\treturn structure.read()\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\treturn token\r\n\t\t\t\t} else\r\n\t\t\t\t\treturn token\r\n\t\t\t} else {\r\n\t\t\t\tif (currentExtensions[token])\r\n\t\t\t\t\treturn currentExtensions[token](read())\r\n\t\t\t\telse\r\n\t\t\t\t\tthrow new Error('Unknown extension ' + token)\r\n\t\t\t}\r\n\t\tcase 7: // fixed value\r\n\t\t\tswitch (token) {\r\n\t\t\t\tcase 0x14: return false\r\n\t\t\t\tcase 0x15: return true\r\n\t\t\t\tcase 0x16: return null\r\n\t\t\t\tcase 0x17: return; // undefined\r\n\t\t\t\t// case 0x19: // half-precision float\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\r\n\t\t\t}\r\n\t\tdefault: // negative int\r\n\t\t\tif (isNaN(token)) {\r\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\r\n\t\t\t\terror.incomplete = true\r\n\t\t\t\tthrow error\r\n\t\t\t}\r\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\r\n\t}\r\n}\r\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\r\nfunction createStructureReader(structure) {\r\n\tfunction readObject() {\r\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\r\n\t\tif (readObject.count++ > 2) {\r\n\t\t\tthis.read = (new Function('r', 'return function(){return {' + structure.map(key => validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}}'))(read)\r\n\t\t\treturn this.read()\r\n\t\t}\r\n\t\tlet object = {}\r\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\r\n\t\t\tlet key = structure[i]\r\n\t\t\tobject[key] = read()\r\n\t\t}\r\n\t\treturn object\r\n\t}\r\n\treadObject.count = 0\r\n\treturn readObject\r\n}\r\n\r\nlet readFixedString = readStringJS\r\nlet readString8 = readStringJS\r\nlet readString16 = readStringJS\r\nlet readString32 = readStringJS\r\n\r\nexports.setExtractor = (extractStrings) => {\r\n\treadFixedString = readString(1)\r\n\treadString8 = readString(2)\r\n\treadString16 = readString(3)\r\n\treadString32 = readString(5)\r\n\tfunction readString(headerLength) {\r\n\t\treturn function readString(length) {\r\n\t\t\tlet string = strings[stringPosition++]\r\n\t\t\tif (string == null) {\r\n\t\t\t\tstrings = extractStrings(position, srcEnd, length, src)\r\n\t\t\t\tstringPosition = 0\r\n\t\t\t\tstring = strings[stringPosition++]\r\n\t\t\t}\r\n\t\t\tlet srcStringLength = string.length\r\n\t\t\tif (srcStringLength <= length) {\r\n\t\t\t\tposition += length\r\n\t\t\t\treturn string\r\n\t\t\t}\r\n\t\t\tsrcString = string\r\n\t\t\tsrcStringStart = position\r\n\t\t\tsrcStringEnd = position + srcStringLength\r\n\t\t\tposition += length\r\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\r\n\t\t}\r\n\t}\r\n}\r\nfunction readStringJS(length) {\r\n\tlet result\r\n\tif (length < 16) {\r\n\t\tif (result = shortStringInJS(length))\r\n\t\t\treturn result\r\n\t}\r\n\tif (length > 64 && decoder)\r\n\t\treturn decoder.decode(src.subarray(position, position += length))\r\n\tconst end = position + length\r\n\tconst units = []\r\n\tresult = ''\r\n\twhile (position < end) {\r\n\t\tconst byte1 = src[position++]\r\n\t\tif ((byte1 & 0x80) === 0) {\r\n\t\t\t// 1 byte\r\n\t\t\tunits.push(byte1)\r\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\r\n\t\t\t// 2 bytes\r\n\t\t\tconst byte2 = src[position++] & 0x3f\r\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\r\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\r\n\t\t\t// 3 bytes\r\n\t\t\tconst byte2 = src[position++] & 0x3f\r\n\t\t\tconst byte3 = src[position++] & 0x3f\r\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\r\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\r\n\t\t\t// 4 bytes\r\n\t\t\tconst byte2 = src[position++] & 0x3f\r\n\t\t\tconst byte3 = src[position++] & 0x3f\r\n\t\t\tconst byte4 = src[position++] & 0x3f\r\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\r\n\t\t\tif (unit > 0xffff) {\r\n\t\t\t\tunit -= 0x10000\r\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\r\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\r\n\t\t\t}\r\n\t\t\tunits.push(unit)\r\n\t\t} else {\r\n\t\t\tunits.push(byte1)\r\n\t\t}\r\n\r\n\t\tif (units.length >= 0x1000) {\r\n\t\t\tresult += fromCharCode.apply(String, units)\r\n\t\t\tunits.length = 0\r\n\t\t}\r\n\t}\r\n\r\n\tif (units.length > 0) {\r\n\t\tresult += fromCharCode.apply(String, units)\r\n\t}\r\n\r\n\treturn result\r\n}\r\n/*function readShortString(length) {\r\n\tlet start = position\r\n\tlet end = start + length\r\n\twhile (position < end) {\r\n\t\tconst byte = src[position++];\r\n\t\tif ((byte & 0x80) > 0) {\r\n\t\t\tposition = end\r\n\t\t\tconsole.log('utf8 slice')\r\n\t\t\treturn src.utf8Slice(start, end)\r\n\t\t}\r\n\t}\r\n\tif (srcStringEnd < end) {\r\n\t\tsrcStringStart = start\r\n\t\tsrcStringEnd = start + 8192\r\n\t\tsrcString = src.toString('latin1', start, srcStringEnd)\r\n\t}\r\n\treturn srcString.slice(start - srcStringStart, end - srcStringStart)\r\n}*/\r\nlet fromCharCode = String.fromCharCode\r\nfunction longStringInJS(length) {\r\n\tlet start = position\r\n\tlet bytes = new Array(length)\r\n\tfor (let i = 0; i < length; i++) {\r\n\t\tconst byte = src[position++];\r\n\t\tif ((byte & 0x80) > 0) {\r\n\t\t\tposition = start\r\n    \t\t\treturn\r\n    \t\t}\r\n    \t\tbytes[i] = byte\r\n    \t}\r\n    \treturn fromCharCode.apply(String, bytes)\r\n}\r\nfunction shortStringInJS(length) {\r\n\tif (length < 4) {\r\n\t\tif (length < 2) {\r\n\t\t\tif (length === 0)\r\n\t\t\t\treturn ''\r\n\t\t\telse {\r\n\t\t\t\tlet a = src[position++]\r\n\t\t\t\tif ((a & 0x80) > 1) {\r\n\t\t\t\t\tposition -= 1\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\treturn fromCharCode(a)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet a = src[position++]\r\n\t\t\tlet b = src[position++]\r\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\r\n\t\t\t\tposition -= 2\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (length < 3)\r\n\t\t\t\treturn fromCharCode(a, b)\r\n\t\t\tlet c = src[position++]\r\n\t\t\tif ((c & 0x80) > 0) {\r\n\t\t\t\tposition -= 3\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\treturn fromCharCode(a, b, c)\r\n\t\t}\r\n\t} else {\r\n\t\tlet a = src[position++]\r\n\t\tlet b = src[position++]\r\n\t\tlet c = src[position++]\r\n\t\tlet d = src[position++]\r\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\r\n\t\t\tposition -= 4\r\n\t\t\treturn\r\n\t\t}\r\n\t\tif (length < 6) {\r\n\t\t\tif (length === 4)\r\n\t\t\t\treturn fromCharCode(a, b, c, d)\r\n\t\t\telse {\r\n\t\t\t\tlet e = src[position++]\r\n\t\t\t\tif ((e & 0x80) > 0) {\r\n\t\t\t\t\tposition -= 5\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\r\n\t\t\t}\r\n\t\t} else if (length < 8) {\r\n\t\t\tlet e = src[position++]\r\n\t\t\tlet f = src[position++]\r\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\r\n\t\t\t\tposition -= 6\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (length < 7)\r\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\r\n\t\t\tlet g = src[position++]\r\n\t\t\tif ((g & 0x80) > 0) {\r\n\t\t\t\tposition -= 7\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\r\n\t\t} else {\r\n\t\t\tlet e = src[position++]\r\n\t\t\tlet f = src[position++]\r\n\t\t\tlet g = src[position++]\r\n\t\t\tlet h = src[position++]\r\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\r\n\t\t\t\tposition -= 8\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (length < 10) {\r\n\t\t\t\tif (length === 8)\r\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet i = src[position++]\r\n\t\t\t\t\tif ((i & 0x80) > 0) {\r\n\t\t\t\t\t\tposition -= 9\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\r\n\t\t\t\t}\r\n\t\t\t} else if (length < 12) {\r\n\t\t\t\tlet i = src[position++]\r\n\t\t\t\tlet j = src[position++]\r\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\r\n\t\t\t\t\tposition -= 10\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tif (length < 11)\r\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\r\n\t\t\t\tlet k = src[position++]\r\n\t\t\t\tif ((k & 0x80) > 0) {\r\n\t\t\t\t\tposition -= 11\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\r\n\t\t\t} else {\r\n\t\t\t\tlet i = src[position++]\r\n\t\t\t\tlet j = src[position++]\r\n\t\t\t\tlet k = src[position++]\r\n\t\t\t\tlet l = src[position++]\r\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\r\n\t\t\t\t\tposition -= 12\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tif (length < 14) {\r\n\t\t\t\t\tif (length === 12)\r\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlet m = src[position++]\r\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\r\n\t\t\t\t\t\t\tposition -= 13\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet m = src[position++]\r\n\t\t\t\t\tlet n = src[position++]\r\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\r\n\t\t\t\t\t\tposition -= 14\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (length < 15)\r\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\r\n\t\t\t\t\tlet o = src[position++]\r\n\t\t\t\t\tif ((o & 0x80) > 0) {\r\n\t\t\t\t\t\tposition -= 15\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction readBin(length) {\r\n\treturn currentDecoder.copyBuffers ?\r\n\t\t// specifically use the copying slice (not the node one)\r\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\r\n\t\tsrc.subarray(position, position += length)\r\n}\r\nfunction readExt(length) {\r\n\tlet type = src[position++]\r\n\tif (currentExtensions[type]) {\r\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\r\n\t}\r\n\telse\r\n\t\tthrow new Error('Unknown extension type ' + type)\r\n}\r\n\r\nfunction getFloat16() {\r\n\tlet byte0 = src[position++]\r\n\tlet byte1 = src[position++]\r\n\tlet half = (byte0 << 8) + byte1\r\n\tlet exp = (half >> 10) & 0x1f\r\n\tlet mant = half & 0x3ff\r\n\tlet val\r\n\tif (exp == 0) val = Math.exp(mant, -24)\r\n\telse if (exp != 31) val = Math.exp(mant + 1024, exp - 25)\r\n\telse val = mant == 0 ? Infinity : NaN\r\n\treturn half & 0x8000 ? -val : val\r\n}\r\nlet glbl = typeof window == 'object' ? window : global\r\n\r\ncurrentExtensions[0] = (dateString) => {\r\n\t// string date extension\r\n\treturn new Date(dateString)\r\n}\r\n\r\ncurrentExtensions[1] = (epochSec) => {\r\n\t// numeric date extension\r\n\treturn new Date(epochSec * 1000)\r\n}\r\n\r\ncurrentExtensions[2] = (buffer) => {\r\n\t// bigint extension\r\n\treturn new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength).getBigUint64(0)\r\n}\r\n\r\ncurrentExtensions[3] = (buffer) => {\r\n\t// negative bigint extension\r\n\treturn BigInt(-1) - (new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength).getBigUint64(0))\r\n}\r\n\r\n// the registration of the record definition extension (tag 6)\r\ncurrentExtensions[6] = (structure) => {\r\n\tlet id = structure[0]\r\n\tstructure = structure.slice(1)\r\n\tcurrentStructures[id - 0x40] = structure\r\n\tstructure.read = createStructureReader(structure)\r\n\treturn structure.read()\r\n}\r\n\r\ncurrentExtensions[8] = (data) => {\r\n\treturn (glbl[data[0]] || Error)(data[1])\r\n}\r\n\r\ncurrentExtensions[9] = (id) => {\r\n\t// id extension (for structured clones)\r\n\tif (!referenceMap)\r\n\t\treferenceMap = new Map()\r\n\tlet token = src[position]\r\n\tlet target\r\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\r\n\t// ahead past references to record structure definitions\r\n\tif ((token >> 5) == 4)\r\n\t\ttarget = []\r\n\telse\r\n\t\ttarget = {}\r\n\r\n\tlet refEntry = { target } // a placeholder object\r\n\treferenceMap.set(id, refEntry)\r\n\tlet targetProperties = read() // read the next value as the target object to id\r\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\r\n\t\treturn Object.assign(target, targetProperties)\r\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\r\n\treturn targetProperties // no cycle, can just use the returned read object\r\n}\r\n\r\ncurrentExtensions[10] = (id) => {\r\n\t// pointer extension (for structured clones)\r\n\tlet refEntry = referenceMap.get(id)\r\n\trefEntry.used = true\r\n\treturn refEntry.target\r\n}\r\n\r\ncurrentExtensions[11] = (array) => new Set(array)\r\n\r\nconst typedArrays = ['Int8','Uint8\t','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\r\n\r\ncurrentExtensions[12] = (data) => {\r\n\tlet [ typeCode, buffer ] = data\r\n\tlet typedArrayName = typedArrays[typeCode]\r\n\tif (!typedArrayName)\r\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\r\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\r\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(buffer, 0).buffer)\r\n}\r\ncurrentExtensions[13] = (data) => {\r\n\treturn new RegExp(data[0], data[1])\r\n}\r\n\r\nfunction saveState(callback) {\r\n\tlet savedSrcEnd = srcEnd\r\n\tlet savedPosition = position\r\n\tlet savedStringPosition = stringPosition\r\n\tlet savedSrcStringStart = srcStringStart\r\n\tlet savedSrcStringEnd = srcStringEnd\r\n\tlet savedSrcString = srcString\r\n\tlet savedStrings = strings\r\n\tlet savedReferenceMap = referenceMap\r\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\r\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\r\n\tlet savedStructures = currentStructures\r\n\tlet savedDecoder = currentDecoder\r\n\tlet value = callback()\r\n\tsrcEnd = savedSrcEnd\r\n\tposition = savedPosition\r\n\tstringPosition = savedStringPosition\r\n\tsrcStringStart = savedSrcStringStart\r\n\tsrcStringEnd = savedSrcStringEnd\r\n\tsrcString = savedSrcString\r\n\tstrings = savedStrings\r\n\treferenceMap = savedReferenceMap\r\n\tsrc = savedSrc\r\n\tcurrentStructures = savedStructures\r\n\tcurrentDecoder = savedDecoder\r\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\r\n\treturn value\r\n}\r\nexports.clearSource = function() {\r\n\tsrc = null\r\n}\r\n\r\nexports.addExtension = function(extension) {\r\n\tcurrentExtensions[extension.tag] = extension.decode\r\n}\r\n\r\nlet mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\r\nfor (let i = 0; i < 256; i++) {\r\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\r\n}\r\nexports.mult10 = mult10\r\nexports.typedArrays = typedArrays\r\n","exports.Encoder = require('./encode').Encoder\r\nexports.Decoder = require('./decode').Decoder\r\nexports.addExtension = require('./encode').addExtension\r\nlet encoder = new exports.Encoder({ useRecords: false })\r\nexports.decode = encoder.decode\r\nexports.encode = encoder.encode\r\nObject.assign(exports, {\r\n\tALWAYS:1,\r\n\tDECIMAL_ROUND: 3,\r\n\tDECIMAL_FIT: 4\r\n})\r\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}